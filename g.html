<!-- <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Black Overlay Controller</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            padding: 20px;
        }

        .container {
            width: 100%;
            max-width: 800px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            padding: 20px;
        }

        #image-preview {
            position: relative;
            width: 100%;
            min-height: 400px;
            border: 2px dashed #ccc;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #uploaded-image {
            max-width: 100%;
            max-height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #black-overlay {
            position: absolute;
            width: 100%;
            height: 150px;
            background: linear-gradient(to top, rgba(0,0,0,1), rgba(0,0,0,1) 30%, transparent);
            bottom: 0;
            left: 0;
            z-index: 2;
            pointer-events: none;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #file-upload {
            display: none;
        }

        .btn {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            margin: 10px 0;
        }

        .btn:hover {
            background-color: #45a049;
        }

        .btn.download {
            background-color: #2196F3;
        }

        .btn.download:hover {
            background-color: #0b7dda;
        }

        /* Resize handle styles */
        .resize-handle {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: #4CAF50;
            border-radius: 50%;
            z-index: 3;
            cursor: ns-resize;
            pointer-events: all;
        }

        #top-handle {
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            cursor: ns-resize;
        }

        .overlay-container {
            position: absolute;
            width: 100%;
            height: 150px;
            bottom: 0;
            left: 0;
            z-index: 2;
        }

        .control-label {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
        }

        .slider-value {
            min-width: 30px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="image-preview">
            <div class="overlay-container" id="overlay-container">
                <div id="black-overlay"></div>
                <div class="resize-handle" id="top-handle"></div>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <input type="file" id="file-upload" accept="image/*">
                <label for="file-upload" class="btn">Upload Image</label>
            </div>
            
            <div class="control-group">
                <div class="control-label">Overlay Height</div>
                <div class="slider-container">
                    <input type="range" id="height-slider" min="50" max="500" value="150">
                    <span class="slider-value" id="height-value">150px</span>
                </div>
            </div>
            
            <div class="control-group">
                <div class="control-label">Fade Length</div>
                <div class="slider-container">
                    <input type="range" id="fade-slider" min="0" max="100" value="30">
                    <span class="slider-value" id="fade-value">30%</span>
                </div>
            </div>

            <div class="control-group">
                <button id="download-btn" class="btn download">Download Image</button>
            </div>
        </div>
    </div>

    <script>
        const imagePreview = document.getElementById('image-preview');
        const fileUpload = document.getElementById('file-upload');
        const blackOverlay = document.getElementById('black-overlay');
        const overlayContainer = document.getElementById('overlay-container');
        const heightSlider = document.getElementById('height-slider');
        const heightValue = document.getElementById('height-value');
        const fadeSlider = document.getElementById('fade-slider');
        const fadeValue = document.getElementById('fade-value');
        const downloadBtn = document.getElementById('download-btn');
        const topHandle = document.getElementById('top-handle');

        // Image Upload
        fileUpload.addEventListener('change', function(event) {
            const file = event.target.files[0];
            const reader = new FileReader();

            reader.onload = function(e) {
                // Remove existing image
                const existingImage = document.getElementById('uploaded-image');
                if (existingImage) {
                    existingImage.remove();
                }

                // Create new image
                const img = document.createElement('img');
                img.src = e.target.result;
                img.id = 'uploaded-image';
                img.crossOrigin = 'anonymous'; // Important for canvas export
                imagePreview.appendChild(img);
            };

            reader.readAsDataURL(file);
        });

        // Height Control
        heightSlider.addEventListener('input', function() {
            const height = this.value;
            overlayContainer.style.height = `${height}px`;
            heightValue.textContent = `${height}px`;
            updateOverlay();
        });

        // Fade Control
        fadeSlider.addEventListener('input', function() {
            const fade = this.value;
            fadeValue.textContent = `${fade}%`;
            updateOverlay();
        });

        // Update Overlay Function
        function updateOverlay() {
            const height = heightSlider.value;
            const fade = fadeSlider.value;
            blackOverlay.style.height = `${height}px`;
            blackOverlay.style.background = `linear-gradient(to top, rgba(0,0,0,1), rgba(0,0,0,1) ${100-fade}%, transparent)`;
        }

        // Resize functionality for top handle
        topHandle.addEventListener('mousedown', function(e) {
            e.preventDefault();
            document.body.style.cursor = 'ns-resize';
            
            const startY = e.clientY;
            const startHeight = overlayContainer.offsetHeight;
            
            function onMouseMove(e) {
                const dy = startY - e.clientY;
                const newHeight = startHeight + dy;
                
                if (newHeight > 50 && newHeight < imagePreview.offsetHeight) {
                    heightSlider.value = newHeight;
                    overlayContainer.style.height = `${newHeight}px`;
                    heightValue.textContent = `${newHeight}px`;
                    updateOverlay();
                }
            }
            
            function onMouseUp() {
                document.body.style.cursor = '';
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });

        // Download functionality
        downloadBtn.addEventListener('click', function() {
            const uploadedImage = document.getElementById('uploaded-image');
            if (!uploadedImage) {
                alert('Please upload an image first');
                return;
            }

            // Create a canvas with the same dimensions as the image
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas dimensions to match the image
            canvas.width = uploadedImage.naturalWidth || uploadedImage.width;
            canvas.height = uploadedImage.naturalHeight || uploadedImage.height;
            
            // Draw the original image
            ctx.drawImage(uploadedImage, 0, 0, canvas.width, canvas.height);
            
            // Calculate overlay position and size relative to the image
            const containerRect = overlayContainer.getBoundingClientRect();
            const previewRect = imagePreview.getBoundingClientRect();
            
            const y = (containerRect.top - previewRect.top) / previewRect.height * canvas.height;
            const height = containerRect.height / previewRect.height * canvas.height;
            const fadePercentage = fadeSlider.value;
            
            // Create gradient
            const gradient = ctx.createLinearGradient(
                0, 
                y + height, 
                0, 
                y
            );
            
            gradient.addColorStop(0, 'rgba(0,0,0,1)');
            gradient.addColorStop((100-fadePercentage)/100, 'rgba(0,0,0,1)');
            gradient.addColorStop(1, 'transparent');
            
            // Apply gradient
            ctx.fillStyle = gradient;
            ctx.fillRect(0, y, canvas.width, height);
            
            // Convert to data URL and download
            const dataURL = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'image-with-overlay.png';
            link.href = dataURL;
            link.click();
        });
    </script>
</body>
</html> -->



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Moveable & Resizable Overlay Editor with Crop</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            padding: 20px;
        }

        .container {
            width: 100%;
            max-width: 800px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            padding: 20px;
        }

        #image-preview {
            position: relative;
            width: 100%;
            min-height: 400px;
            border: 2px dashed #ccc;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #uploaded-image {
            max-width: 100%;
            max-height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .overlay-container {
            position: absolute;
            width: 200px;
            height: 150px;
            bottom: 50px;
            left: 50px;
            z-index: 2;
            border: 2px solid transparent; /* Initially transparent border */
            cursor: move;
        }

        .overlay-container.active {
            border: 2px dashed #4CAF50; /* Shows border when active */
        }

        #black-overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(to top, rgba(0,0,0,1), rgba(0,0,0,1) 70%, transparent);
            z-index: 2;
            pointer-events: none;
        }

        #text-overlay {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            color: #FFD700;
            font-size: 28px;
            font-weight: bold;
            text-align: center;
            z-index: 3;
            padding: 0 10px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            pointer-events: none;
            white-space: pre-line;
            box-sizing: border-box;
        }

        /* Resize handles */
        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #4CAF50;
            border-radius: 50%;
            z-index: 4;
        }

        .n-resize {
            top: -5px;
            left: 50%;
            transform: translateX(-50%);
            cursor: ns-resize;
        }

        .e-resize {
            top: 50%;
            right: -5px;
            transform: translateY(-50%);
            cursor: ew-resize;
        }

        .s-resize {
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            cursor: ns-resize;
        }

        .w-resize {
            top: 50%;
            left: -5px;
            transform: translateY(-50%);
            cursor: ew-resize;
        }

        .nw-resize {
            top: -5px;
            left: -5px;
            cursor: nwse-resize;
        }

        .ne-resize {
            top: -5px;
            right: -5px;
            cursor: nesw-resize;
        }

        .se-resize {
            bottom: -5px;
            right: -5px;
            cursor: nwse-resize;
        }

        .sw-resize {
            bottom: -5px;
            left: -5px;
            cursor: nesw-resize;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 200px;
        }

        #file-upload {
            display: none;
        }

        .btn {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            margin: 10px 0;
        }

        .btn:hover {
            background-color: #45a049;
        }

        .btn.download {
            background-color: #2196F3;
        }

        .btn.download:hover {
            background-color: #0b7dda;
        }

        .btn.crop {
            background-color: #ff9800;
        }

        .btn.crop:hover {
            background-color: #e68a00;
        }

        .btn.cancel-crop {
            background-color: #f44336;
        }

        .btn.cancel-crop:hover {
            background-color: #d32f2f;
        }

        .control-label {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
        }

        .slider-value {
            min-width: 30px;
            text-align: center;
        }

        textarea {
            width: 100%;
            padding: 8px;
            resize: vertical;
            border-radius: 5px;
            border: 1px solid #ccc;
            font-family: Arial, sans-serif;
            min-height: 60px;
        }

        .text-controls {
            margin-top: 20px;
            border-top: 1px solid #eee;
            padding-top: 20px;
            width: 100%;
        }

        .font-size-control, .color-control, .text-align-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        select {
            padding: 5px;
            border-radius: 5px;
        }

        input[type="color"] {
            width: 40px;
            height: 30px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .control-row {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 10px;
            width: 100%;
        }

        .branding {
            font-size: 12px;
            color: #888;
            text-align: center;
            margin-top: 10px;
        }

        .position-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 10px;
            width: 100%;
        }

        /* Crop overlay styles */
        #crop-overlay {
            position: absolute;
            border: 2px dashed rgba(255, 255, 255, 0.8);
            background-color: rgba(0, 0, 0, 0.3);
            cursor: move;
            z-index: 10;
            display: none;
        }

        .crop-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: white;
            border: 1px solid #333;
            z-index: 11;
        }

        .crop-nw { top: -6px; left: -6px; cursor: nwse-resize; }
        .crop-ne { top: -6px; right: -6px; cursor: nesw-resize; }
        .crop-sw { bottom: -6px; left: -6px; cursor: nesw-resize; }
        .crop-se { bottom: -6px; right: -6px; cursor: nwse-resize; }
        .crop-n { top: -6px; left: 50%; margin-left: -6px; cursor: ns-resize; }
        .crop-s { bottom: -6px; left: 50%; margin-left: -6px; cursor: ns-resize; }
        .crop-w { top: 50%; left: -6px; margin-top: -6px; cursor: ew-resize; }
        .crop-e { top: 50%; right: -6px; margin-top: -6px; cursor: ew-resize; }

        .crop-controls {
            display: none;
            width: 100%;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="image-preview">
            <div id="crop-overlay">
                <div class="crop-handle crop-nw"></div>
                <div class="crop-handle crop-ne"></div>
                <div class="crop-handle crop-sw"></div>
                <div class="crop-handle crop-se"></div>
                <div class="crop-handle crop-n"></div>
                <div class="crop-handle crop-s"></div>
                <div class="crop-handle crop-w"></div>
                <div class="crop-handle crop-e"></div>
            </div>
            <div class="overlay-container" id="overlay-container">
                <div id="black-overlay"></div>
                <div class="resize-handle n-resize" id="n-handle"></div>
                <div class="resize-handle e-resize" id="e-handle"></div>
                <div class="resize-handle s-resize" id="s-handle"></div>
                <div class="resize-handle w-resize" id="w-handle"></div>
                <div class="resize-handle nw-resize" id="nw-handle"></div>
                <div class="resize-handle ne-resize" id="ne-handle"></div>
                <div class="resize-handle se-resize" id="se-handle"></div>
                <div class="resize-handle sw-resize" id="sw-handle"></div>
                <div id="text-overlay">THE BIGGEST OSCAR
NOMINATION SNUBS
OF ALL TIME</div>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <input type="file" id="file-upload" accept="image/*">
                <label for="file-upload" class="btn">Upload Image</label>
            </div>
            
            <div class="control-group">
                <button id="crop-btn" class="btn crop">Crop Image</button>
                <div class="crop-controls" id="crop-controls">
                    <button id="apply-crop-btn" class="btn crop">Apply Crop</button>
                    <button id="cancel-crop-btn" class="btn cancel-crop">Cancel</button>
                </div>
            </div>
            
            <div class="control-group">
                <div class="control-label">Fade Percentage</div>
                <div class="slider-container">
                    <input type="range" id="fade-slider" min="0" max="100" value="30">
                    <span class="slider-value" id="fade-value">30%</span>
                </div>
            </div>

            <div class="position-controls">
                <div class="control-label">Overlay Position and Size</div>
                <div class="control-row">
                    <div class="slider-container">
                        <label>Width:</label>
                        <input type="number" id="width-input" min="50" value="200">px
                    </div>
                    <div class="slider-container">
                        <label>Height:</label>
                        <input type="number" id="height-input" min="50" value="150">px
                    </div>
                </div>
                <div class="control-row">
                    <div class="slider-container">
                        <label>Left:</label>
                        <input type="number" id="left-input" min="0" value="50">px
                    </div>
                    <div class="slider-container">
                        <label>Top:</label>
                        <input type="number" id="top-input" min="0" value="200">px
                    </div>
                </div>
            </div>

            <div class="text-controls">
                <div class="control-label">Text Overlay</div>
                <textarea id="text-input" rows="3" placeholder="Enter your text here...">THE BIGGEST OSCAR
NOMINATION SNUBS
OF ALL TIME</textarea>
                
                <div class="control-row">
                    <div class="font-size-control">
                        <label for="font-size">Font Size:</label>
                        <input type="range" id="font-size-slider" min="12" max="60" value="28">
                        <span id="font-size-value">28px</span>
                    </div>
                    
                    <div class="color-control">
                        <label for="text-color">Color:</label>
                        <input type="color" id="text-color" value="#FFD700">
                    </div>
                </div>
                
                <div class="control-row">
                    <div class="text-align-control">
                        <label for="text-align">Alignment:</label>
                        <select id="text-align">
                            <option value="left">Left</option>
                            <option value="center" selected>Center</option>
                            <option value="right">Right</option>
                        </select>
                    </div>
                    
                    <div class="text-align-control">
                        <label for="text-position">Bottom Position:</label>
                        <input type="range" id="position-slider" min="5" max="60" value="20">
                        <span id="position-value">20px</span>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <button id="download-btn" class="btn download">Download Image</button>
            </div>
        </div>
        
        <div class="branding">
            <p>wealth</p>
        </div>
    </div>

    <script>
        const imagePreview = document.getElementById('image-preview');
        const fileUpload = document.getElementById('file-upload');
        const blackOverlay = document.getElementById('black-overlay');
        const overlayContainer = document.getElementById('overlay-container');
        const fadeSlider = document.getElementById('fade-slider');
        const fadeValue = document.getElementById('fade-value');
        const downloadBtn = document.getElementById('download-btn');
        
        // Position and size inputs
        const widthInput = document.getElementById('width-input');
        const heightInput = document.getElementById('height-input');
        const leftInput = document.getElementById('left-input');
        const topInput = document.getElementById('top-input');
        
        // Text controls
        const textOverlay = document.getElementById('text-overlay');
        const textInput = document.getElementById('text-input');
        const fontSizeSlider = document.getElementById('font-size-slider');
        const fontSizeValue = document.getElementById('font-size-value');
        const textColor = document.getElementById('text-color');
        const textAlign = document.getElementById('text-align');
        const positionSlider = document.getElementById('position-slider');
        const positionValue = document.getElementById('position-value');

        // Crop elements
        const cropOverlay = document.getElementById('crop-overlay');
        const cropBtn = document.getElementById('crop-btn');
        const cropControls = document.getElementById('crop-controls');
        const applyCropBtn = document.getElementById('apply-crop-btn');
        const cancelCropBtn = document.getElementById('cancel-crop-btn');

        // Make overlay draggable
        let isDragging = false;
        let dragStartX, dragStartY;
        let initialLeft, initialTop;

        overlayContainer.addEventListener('mousedown', function(e) {
            // Don't initiate drag if clicking on a resize handle
            if (e.target.classList.contains('resize-handle')) return;
            
            isDragging = true;
            overlayContainer.classList.add('active');
            
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            
            const rect = overlayContainer.getBoundingClientRect();
            initialLeft = rect.left - imagePreview.getBoundingClientRect().left;
            initialTop = rect.top - imagePreview.getBoundingClientRect().top;
            
            e.preventDefault();
        });

        document.addEventListener('mousemove', function(e) {
            if (!isDragging) return;
            
            const dx = e.clientX - dragStartX;
            const dy = e.clientY - dragStartY;
            
            const newLeft = initialLeft + dx;
            const newTop = initialTop + dy;
            
            // Constrain to image boundaries
            const previewRect = imagePreview.getBoundingClientRect();
            const containerRect = overlayContainer.getBoundingClientRect();
            
            const maxLeft = previewRect.width - containerRect.width;
            const maxTop = previewRect.height - containerRect.height;
            
            const constrainedLeft = Math.max(0, Math.min(newLeft, maxLeft));
            const constrainedTop = Math.max(0, Math.min(newTop, maxTop));
            
            overlayContainer.style.left = `${constrainedLeft}px`;
            overlayContainer.style.top = `${constrainedTop}px`;
            
            // Update position inputs
            leftInput.value = Math.round(constrainedLeft);
            topInput.value = Math.round(constrainedTop);
        });

        document.addEventListener('mouseup', function() {
            if (isDragging) {
                isDragging = false;
                overlayContainer.classList.remove('active');
            }
        });

        // Make overlay resizable with 8 handles
        const resizeHandles = {
            'n-handle': { edge: 'top', cursor: 'ns-resize' },
            'e-handle': { edge: 'right', cursor: 'ew-resize' },
            's-handle': { edge: 'bottom', cursor: 'ns-resize' },
            'w-handle': { edge: 'left', cursor: 'ew-resize' },
            'nw-handle': { edge: 'topleft', cursor: 'nwse-resize' },
            'ne-handle': { edge: 'topright', cursor: 'nesw-resize' },
            'se-handle': { edge: 'bottomright', cursor: 'nwse-resize' },
            'sw-handle': { edge: 'bottomleft', cursor: 'nesw-resize' }
        };

        for (const handleId in resizeHandles) {
            const handle = document.getElementById(handleId);
            const config = resizeHandles[handleId];
            
            handle.addEventListener('mousedown', function(e) {
                e.stopPropagation();
                
                isDragging = true;
                overlayContainer.classList.add('active');
                document.body.style.cursor = config.cursor;
                
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                
                const rect = overlayContainer.getBoundingClientRect();
                initialLeft = rect.left - imagePreview.getBoundingClientRect().left;
                initialTop = rect.top - imagePreview.getBoundingClientRect().top;
                const initialWidth = rect.width;
                const initialHeight = rect.height;
                
                function onResizeMouseMove(e) {
                    if (!isDragging) return;
                    
                    const dx = e.clientX - dragStartX;
                    const dy = e.clientY - dragStartY;
                    
                    let newLeft = initialLeft;
                    let newTop = initialTop;
                    let newWidth = initialWidth;
                    let newHeight = initialHeight;
                    
                    // Handle different resize edges
                    switch (config.edge) {
                        case 'top':
                            newTop = initialTop + dy;
                            newHeight = initialHeight - dy;
                            break;
                        case 'right':
                            newWidth = initialWidth + dx;
                            break;
                        case 'bottom':
                            newHeight = initialHeight + dy;
                            break;
                        case 'left':
                            newLeft = initialLeft + dx;
                            newWidth = initialWidth - dx;
                            break;
                        case 'topleft':
                            newLeft = initialLeft + dx;
                            newTop = initialTop + dy;
                            newWidth = initialWidth - dx;
                            newHeight = initialHeight - dy;
                            break;
                        case 'topright':
                            newTop = initialTop + dy;
                            newWidth = initialWidth + dx;
                            newHeight = initialHeight - dy;
                            break;
                        case 'bottomright':
                            newWidth = initialWidth + dx;
                            newHeight = initialHeight + dy;
                            break;
                        case 'bottomleft':
                            newLeft = initialLeft + dx;
                            newWidth = initialWidth - dx;
                            newHeight = initialHeight + dy;
                            break;
                    }
                    
                    // Constrain minimum size
                    if (newWidth < 50) {
                        newWidth = 50;
                        if (config.edge.includes('left')) {
                            newLeft = initialLeft + initialWidth - 50;
                        }
                    }
                    
                    if (newHeight < 50) {
                        newHeight = 50;
                        if (config.edge.includes('top')) {
                            newTop = initialTop + initialHeight - 50;
                        }
                    }
                    
                    // Apply styles
                    overlayContainer.style.left = `${newLeft}px`;
                    overlayContainer.style.top = `${newTop}px`;
                    overlayContainer.style.width = `${newWidth}px`;
                    overlayContainer.style.height = `${newHeight}px`;
                    
                    // Update inputs
                    widthInput.value = Math.round(newWidth);
                    heightInput.value = Math.round(newHeight);
                    leftInput.value = Math.round(newLeft);
                    topInput.value = Math.round(newTop);
                }
                
                function onResizeMouseUp() {
                    isDragging = false;
                    overlayContainer.classList.remove('active');
                    document.body.style.cursor = '';
                    document.removeEventListener('mousemove', onResizeMouseMove);
                    document.removeEventListener('mouseup', onResizeMouseUp);
                }
                
                document.addEventListener('mousemove', onResizeMouseMove);
                document.addEventListener('mouseup', onResizeMouseUp);
            });
        }

        // Image Upload
        fileUpload.addEventListener('change', function(event) {
            const file = event.target.files[0];
            const reader = new FileReader();

            reader.onload = function(e) {
                // Remove existing image
                const existingImage = document.getElementById('uploaded-image');
                if (existingImage) {
                    existingImage.remove();
                }

                // Create new image
                const img = document.createElement('img');
                img.src = e.target.result;
                img.id = 'uploaded-image';
                img.crossOrigin = 'anonymous'; // Important for canvas export
                imagePreview.appendChild(img);
                
                // Center the overlay by default
                setTimeout(() => {
                    const previewRect = imagePreview.getBoundingClientRect();
                    const overlayRect = overlayContainer.getBoundingClientRect();
                    
                    const newLeft = (previewRect.width - overlayRect.width) / 2;
                    const newTop = (previewRect.height - overlayRect.height) / 2;
                    
                    overlayContainer.style.left = `${newLeft}px`;
                    overlayContainer.style.top = `${newTop}px`;
                    
                    leftInput.value = Math.round(newLeft);
                    topInput.value = Math.round(newTop);
                }, 100);
            };

            reader.readAsDataURL(file);
        });

        // Manual position and size inputs
        widthInput.addEventListener('input', function() {
            overlayContainer.style.width = `${this.value}px`;
        });
        
        heightInput.addEventListener('input', function() {
            overlayContainer.style.height = `${this.value}px`;
        });
        
        leftInput.addEventListener('input', function() {
            overlayContainer.style.left = `${this.value}px`;
        });
        
        topInput.addEventListener('input', function() {
            overlayContainer.style.top = `${this.value}px`;
        });

        // Fade Control
        fadeSlider.addEventListener('input', function() {
            const fade = this.value;
            fadeValue.textContent = `${fade}%`;
            updateOverlay();
        });

        // Text Input with preserved line breaks
        textInput.addEventListener('input', function() {
            textOverlay.textContent = this.value;
        });

        // Font Size Control
        fontSizeSlider.addEventListener('input', function() {
            const size = this.value;
            textOverlay.style.fontSize = `${size}px`;
            fontSizeValue.textContent = `${size}px`;
        });

        // Color Control
        textColor.addEventListener('input', function() {
            textOverlay.style.color = this.value;
        });

        // Text Alignment
        textAlign.addEventListener('change', function() {
            textOverlay.style.textAlign = this.value;
        });

        // Position Control
        positionSlider.addEventListener('input', function() {
            const pos = this.value;
            textOverlay.style.bottom = `${pos}px`;
            positionValue.textContent = `${pos}px`;
        });

        // Update Overlay Function
        function updateOverlay() {
            const fade = fadeSlider.value;
            blackOverlay.style.background = `linear-gradient(to top, rgba(0,0,0,1), rgba(0,0,0,1) ${100-fade}%, transparent)`;
        }

        // Crop functionality
        let isCropping = false;
        let cropStartX, cropStartY;
        let cropInitialLeft, cropInitialTop, cropInitialWidth, cropInitialHeight;
        let activeCropHandle = null;

        cropBtn.addEventListener('click', function() {
            if (!document.getElementById('uploaded-image')) {
                alert('Please upload an image first');
                return;
            }

            isCropping = true;
            cropControls.style.display = 'flex';
            
            // Hide the text overlay during cropping
            overlayContainer.style.display = 'none';
            
            // Initialize crop overlay
            const previewRect = imagePreview.getBoundingClientRect();
            const imgRect = document.getElementById('uploaded-image').getBoundingClientRect();
            
            // Calculate relative position of image within preview
            const imgLeft = imgRect.left - previewRect.left;
            const imgTop = imgRect.top - previewRect.top;
            
            // Set crop overlay to cover the entire image
            cropOverlay.style.display = 'block';
            cropOverlay.style.left = `${imgLeft}px`;
            cropOverlay.style.top = `${imgTop}px`;
            cropOverlay.style.width = `${imgRect.width}px`;
            cropOverlay.style.height = `${imgRect.height}px`;
        });

        // Handle crop overlay dragging
        cropOverlay.addEventListener('mousedown', function(e) {
            if (!isCropping) return;
            
            // Check if we're clicking on a handle
            if (e.target.classList.contains('crop-handle')) {
                activeCropHandle = e.target.classList[1].replace('crop-', '');
                document.body.style.cursor = e.target.style.cursor;
            } else {
                activeCropHandle = 'move';
                document.body.style.cursor = 'move';
            }
            
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            
            const rect = cropOverlay.getBoundingClientRect();
            cropInitialLeft = rect.left - imagePreview.getBoundingClientRect().left;
            cropInitialTop = rect.top - imagePreview.getBoundingClientRect().top;
            cropInitialWidth = rect.width;
            cropInitialHeight = rect.height;
            
            e.preventDefault();
            e.stopPropagation();
        });

        document.addEventListener('mousemove', function(e) {
            if (!isCropping || !activeCropHandle) return;
            
            const dx = e.clientX - dragStartX;
            const dy = e.clientY - dragStartY;
            
            let newLeft = cropInitialLeft;
            let newTop = cropInitialTop;
            let newWidth = cropInitialWidth;
            let newHeight = cropInitialHeight;
            
            const previewRect = imagePreview.getBoundingClientRect();
            const imgRect = document.getElementById('uploaded-image').getBoundingClientRect();
            const imgLeft = imgRect.left - previewRect.left;
            const imgTop = imgRect.top - previewRect.top;
            
            // Handle different crop operations
            switch (activeCropHandle) {
                case 'move':
                    newLeft = cropInitialLeft + dx;
                    newTop = cropInitialTop + dy;
                    
                    // Constrain to image boundaries
                    newLeft = Math.max(imgLeft, Math.min(newLeft, imgLeft + imgRect.width - newWidth));
                    newTop = Math.max(imgTop, Math.min(newTop, imgTop + imgRect.height - newHeight));
                    break;
                    
                case 'n':
                    newTop = cropInitialTop + dy;
                    newHeight = cropInitialHeight - dy;
                    break;
                case 'e':
                    newWidth = cropInitialWidth + dx;
                    break;
                case 's':
                    newHeight = cropInitialHeight + dy;
                    break;
                case 'w':
                    newLeft = cropInitialLeft + dx;
                    newWidth = cropInitialWidth - dx;
                    break;
                case 'nw':
                    newLeft = cropInitialLeft + dx;
                    newTop = cropInitialTop + dy;
                    newWidth = cropInitialWidth - dx;
                    newHeight = cropInitialHeight - dy;
                    break;
                case 'ne':
                    newTop = cropInitialTop + dy;
                    newWidth = cropInitialWidth + dx;
                    newHeight = cropInitialHeight - dy;
                    break;
                case 'se':
                    newWidth = cropInitialWidth + dx;
                    newHeight = cropInitialHeight + dy;
                    break;
                case 'sw':
                    newLeft = cropInitialLeft + dx;
                    newWidth = cropInitialWidth - dx;
                    newHeight = cropInitialHeight + dy;
                    break;
            }
            
            // Constrain to image boundaries and minimum size
            if (activeCropHandle !== 'move') {
                // Ensure crop area stays within image
                newLeft = Math.max(imgLeft, newLeft);
                newTop = Math.max(imgTop, newTop);
                newWidth = Math.min(newWidth, imgLeft + imgRect.width - newLeft);
                newHeight = Math.min(newHeight, imgTop + imgRect.height - newTop);
                
                // Minimum size
                if (newWidth < 50) {
                    newWidth = 50;
                    if (activeCropHandle.includes('w')) {
                        newLeft = cropInitialLeft + cropInitialWidth - 50;
                    }
                }
                
                if (newHeight < 50) {
                    newHeight = 50;
                    if (activeCropHandle.includes('n')) {
                        newTop = cropInitialTop + cropInitialHeight - 50;
                    }
                }
            }
            
            // Apply new crop dimensions
            cropOverlay.style.left = `${newLeft}px`;
            cropOverlay.style.top = `${newTop}px`;
            cropOverlay.style.width = `${newWidth}px`;
            cropOverlay.style.height = `${newHeight}px`;
        });

        document.addEventListener('mouseup', function() {
            if (isCropping && activeCropHandle) {
                activeCropHandle = null;
                document.body.style.cursor = '';
            }
        });

        // Apply crop
        applyCropBtn.addEventListener('click', function() {
            if (!isCropping) return;
            
            const uploadedImage = document.getElementById('uploaded-image');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Get crop dimensions relative to the image
            const previewRect = imagePreview.getBoundingClientRect();
            const imgRect = uploadedImage.getBoundingClientRect();
            const cropRect = cropOverlay.getBoundingClientRect();
            
            // Calculate scale factors (original image size vs displayed size)
            const scaleX = uploadedImage.naturalWidth / imgRect.width;
            const scaleY = uploadedImage.naturalHeight / imgRect.height;
            
            // Calculate crop coordinates in original image dimensions
            const cropX = (cropRect.left - imgRect.left) * scaleX;
            const cropY = (cropRect.top - imgRect.top) * scaleY;
            const cropWidth = cropRect.width * scaleX;
            const cropHeight = cropRect.height * scaleY;
            
            // Set canvas dimensions to match crop area
            canvas.width = cropWidth;
            canvas.height = cropHeight;
            
            // Draw the cropped portion
            ctx.drawImage(
                uploadedImage, 
                cropX, cropY, cropWidth, cropHeight, // Source rectangle
                0, 0, cropWidth, cropHeight          // Destination rectangle
            );
            
            // Replace the image with the cropped version
            uploadedImage.src = canvas.toDataURL('image/png');
            
            // Reset crop UI
            cancelCrop();
        });

        // Cancel crop
        cancelCropBtn.addEventListener('click', cancelCrop);

        function cancelCrop() {
            isCropping = false;
            cropOverlay.style.display = 'none';
            cropControls.style.display = 'none';
            overlayContainer.style.display = '';
            activeCropHandle = null;
            document.body.style.cursor = '';
        }

        // Download functionality
        downloadBtn.addEventListener('click', function() {
            const uploadedImage = document.getElementById('uploaded-image');
            if (!uploadedImage) {
                alert('Please upload an image first');
                return;
            }

            // Create a canvas with the same dimensions as the image
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas dimensions to match the image
            canvas.width = uploadedImage.naturalWidth || uploadedImage.width;
            canvas.height = uploadedImage.naturalHeight || uploadedImage.height;
            
            // Draw the original image
            ctx.drawImage(uploadedImage, 0, 0, canvas.width, canvas.height);
            
            // Calculate overlay position and size relative to the image
            const overlayRect = overlayContainer.getBoundingClientRect();
            const previewRect = imagePreview.getBoundingClientRect();
            
            const scaleX = canvas.width / previewRect.width;
            const scaleY = canvas.height / previewRect.height;
            
            const overlayLeft = (overlayRect.left - previewRect.left) * scaleX;
            const overlayTop = (overlayRect.top - previewRect.top) * scaleY;
            const overlayWidth = overlayRect.width * scaleX;
            const overlayHeight = overlayRect.height * scaleY;
            
            // Create gradient
            const fadePercentage = fadeSlider.value;
            const gradient = ctx.createLinearGradient(
                0, 
                overlayTop, 
                0, 
                overlayTop + overlayHeight
            );
            
            gradient.addColorStop(0, 'transparent');
            gradient.addColorStop(fadePercentage/100, 'rgba(0,0,0,1)');
            gradient.addColorStop(1, 'rgba(0,0,0,1)');
            
            // Apply gradient
            ctx.fillStyle = gradient;
            ctx.fillRect(overlayLeft, overlayTop, overlayWidth, overlayHeight);
            
            // Add text
            const text = textInput.value;
            if (text) {
                // Calculate font size proportional to image
                const fontSize = parseInt(fontSizeSlider.value) * scaleY;
                
                // Calculate bottom position
                const bottomPos = parseInt(positionValue.textContent) * scaleY;
                
                // Set text properties
                ctx.fillStyle = textColor.value;
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = textAlign.value;
                
                // Calculate text position
                let x;
                if (textAlign.value === 'center') {
                    x = overlayLeft + (overlayWidth / 2);
                } else if (textAlign.value === 'right') {
                    x = overlayLeft + overlayWidth - 20;
                } else {
                    x = overlayLeft + 20;
                }
                
                // Add text shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                ctx.shadowBlur = 3;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                
                // Draw text with preserved line breaks
                const lines = text.split('\n');
                const lineHeight = fontSize * 1.2;
                let baseY = overlayTop + overlayHeight - bottomPos;
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const y = baseY - ((lines.length - 1 - i) * lineHeight);
                    ctx.fillText(line, x, y);
                }
                
                // Add branding if needed
                ctx.fillStyle = '#888';
                ctx.font = `${fontSize * 0.4}px Arial`;
                ctx.fillText('wealth', overlayLeft + (overlayWidth / 2), overlayTop + overlayHeight - bottomPos / 3);
            }
            
            // Convert to data URL and download
            const dataURL = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'image-with-overlay.png';
            link.href = dataURL;
            link.click();
        });
        
        // Initialize
        updateOverlay();
        
        // Set initial position
        // Default to bottom part of the image preview
        const previewRect = imagePreview.getBoundingClientRect();
        overlayContainer.style.left = '50px';
        overlayContainer.style.top = `${previewRect.height - 200}px`;
        leftInput.value = 50;
        topInput.value = Math.round(previewRect.height - 200);
    </script>
</body>
</html>